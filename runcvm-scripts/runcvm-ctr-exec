#!/.runcvm/guest/bin/bash -e

# See https://qemu-project.gitlab.io/qemu/interop/qemu-ga-ref.html

# Load original environment
. /.runcvm/config

# Load defaults and aliases
. $RUNCVM_GUEST/scripts/runcvm-ctr-defaults

env() {
  busybox env "$@"
}

to_bin() {
  # tab, LF, space, ', ", \
  tr "\011\012\040\047\042\134" '\200\201\202\203\204\205'
}

# Expects:
# - To be run as root
# - To be given env vars
# - To be given arguments
#   $1 <uid>:<gid>:<additionalGids>
#   $2 <cwd>
#   $3 <ENV-HOME-boolean>
#   $4 <wantsTerminal-boolean>
#   $(5...) <command> <args>

command="$RUNCVM_GUEST/scripts/runcvm-vm-exec"
uidgid="$1"
cwd="$2"
hasHome="$3"
wantsTerminal="$4"
shift 4

# Parse uidgid and construct args array for the call to $command within the VM:
# $1 <uid>
# $2 <gid>
# $3 <cwd>
# $(4...) <command> <args>

IFS=':' read -r uid gid additionalGids <<< "$uidgid"
args=("$@")

if [ ${#args[@]} -gt 0 ]; then
  args_bin=$(printf '%s\n' "${args[@]}" | to_bin)
fi

# If the HOME env var was not set either in the image, or via docker run, or via docker exec,
# then set HOME to the requested user's default homedir.
#
# - See runcvm-ctr-entrypoint for full details of how/why hasHome is needed and HOME gets set.

if [ "$hasHome" != "1" ]; then
  # Either this script needs to look up uid's HOME or else runcvm-vm-exec does; for now, we do it here.
  HOME=$(getent passwd "$uid" | cut -d':' -f6)
fi

# Clean RUNCVM env vars
clean_env

# N.B. Only exported env vars will be returned and sent
mapfile -t env < <(env -u _ -u SHLVL -u PWD)

if [ ${#env[@]} -gt 0 ]; then
  env_bin=$(printf '%s\n' "${env[@]}" | to_bin)
fi

if [ "$wantsTerminal" = "true" ]; then
  opts=(-t)
fi

retries=30 # 15 seconds
delay=0 # Signal that extra time should be allowed for RunCVM VM, its init and its dropbear sshd to start after the above conditions are satisfied

while ! [ -s /.runcvm/dropbear/key ] || ! load_network
do
  if [ $retries -gt 0 ]; then
    retries=$((retries-1))
    delay=1
    sleep 0.5
    continue
  fi

  echo "Error: RunCVM container not yet started" >&2
  exit 1
done

# If startup was detected, wait a few extra seconds for dropbear sshd to be ready
if [ "$delay" -ne 0 ]; then
  sleep 2
fi

# Determine the SSH target IP
# Strategy: Loopback Connection (Force 127.0.0.1)
# We now configure the container environment (via runcvm-ctr-firecracker) to
# DNAT 127.0.0.1:22222 to the VM's internal IP.
SSH_CONNECT_IP="127.0.0.1"
SSH_TARGET_IP="$SSH_CONNECT_IP" # For dbclient

# Determine IP to check for connectivity (The real VM IP)
# load_network (called in loop above) should have set DOCKER_IF_IP
# If not (e.g. loaded 'default' but it was weird), try to find a valid IP
VM_CHECK_IP="$DOCKER_IF_IP"

if [ -z "$VM_CHECK_IP" ] || [ "$VM_CHECK_IP" = "-" ]; then
  # Fallback: check eth0 explicitly
  if [ -s /.runcvm/network/devices/eth0 ]; then
     read _ _ _ VM_CHECK_IP _ _ < /.runcvm/network/devices/eth0
  fi
fi

# Verify connectivity before connecting
# This avoids "Host is unreachable" errors if the VM isn't fully ready or ARP is converging
if [ -n "$VM_CHECK_IP" ] && [ "$VM_CHECK_IP" != "-" ]; then
   if [ "$RUNCVM_LOG_LEVEL" = "DEBUG" ]; then echo "Waiting for VM ($VM_CHECK_IP)..." >&2; fi
   
   # Wait for VM to answer ping (up to 5 seconds)
   # We need the VM to be reachable via the bridge for socat to work
   check_count=0
   while ! busybox ping -c 1 -W 1 "$VM_CHECK_IP" >/dev/null 2>&1 && [ $check_count -lt 25 ]; do
     sleep 0.2
     check_count=$((check_count+1))
   done
   
   # Wait for SSH Port (22222) to be open (up to 10 seconds)
   # This avoids "Connection refused" if network is up but Dropbear isn't ready
   port_count=0
   while ! nc -z -w 1 "$VM_CHECK_IP" 22222 >/dev/null 2>&1 && [ $port_count -lt 20 ]; do
      sleep 0.5
      port_count=$((port_count+1))
   done

   if [ $check_count -ge 25 ]; then
     echo "Warning: VM $VM_CHECK_IP did not respond to ping, connection may fail" >&2
   fi
else
   # If we can't find the IP, we just proceed and hope sending to localhost works (maybe legacy mode)
   :
fi

# Debug client key
if [ "$RUNCVM_LOG_LEVEL" = "DEBUG" ]; then
  echo "DEBUG: Client Key Check:" >&2
  ls -l /.runcvm/dropbear/key >&2
fi

# Finally, execute the command via SSH
# We use dbclient (Dropbear's SSH client)
# -y -y: Always accept hostkey AND suppress the confirmation message
# -i: Identify file
# -p: Port
# Note: Host variable is passed as argument, but we proxy via 127.0.0.1
# using socat. So we connect to root@127.0.0.1
exec $RUNCVM_GUEST/usr/bin/dbclient "${opts[@]}" -p 22222 -y -y -i /.runcvm/dropbear/key root@$SSH_TARGET_IP "$command '$uidgid' '$(echo -n $cwd | to_bin)' '$args_bin' '$env_bin'"
