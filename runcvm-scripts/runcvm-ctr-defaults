#!/bin/bash

RUNCVM_GUEST=${RUNCVM_GUEST:-/.runcvm/guest}
RUNCVM_PATH=$RUNCVM_GUEST/usr/sbin:$RUNCVM_GUEST/usr/bin:$RUNCVM_GUEST/sbin:$RUNCVM_GUEST/bin:$RUNCVM_GUEST/usr/lib/qemu

SSHD_PORT=22222

# ============================================================
# LOGGING SYSTEM
# Severity levels: DEBUG, INFO, ERROR, OFF
# Control via: RUNCVM_LOG_LEVEL environment variable
# ============================================================

# Default log level (can be overridden by environment)
RUNCVM_LOG_LEVEL="${RUNCVM_LOG_LEVEL:-OFF}"

# Log severity levels (numeric for comparison)
# Log severity levels (numeric for comparison)
# Replaced associative array with POSIX sh case statement
case "$RUNCVM_LOG_LEVEL" in
  DEBUG) CURRENT_LOG_LEVEL=0 ;;
  INFO|LOG) CURRENT_LOG_LEVEL=1 ;;
  ERROR) CURRENT_LOG_LEVEL=2 ;;
  OFF|*) CURRENT_LOG_LEVEL=999 ;;
esac

# Core logging function
_log() {
  local severity="$1"
  shift
  local message="$*"
  local severity_level=999
  
  case "$severity" in
    DEBUG) severity_level=0 ;;
    INFO|LOG) severity_level=1 ;;
    ERROR) severity_level=2 ;;
  esac
  
  # Only log if severity meets threshold
  if [ "$severity_level" -ge "$CURRENT_LOG_LEVEL" ]; then
    local log_entry="[$(date '+%Y-%m-%d %H:%M:%S')] [RunCVM] [$severity] $message"
    
    # Check if we should log to file
    if [ -n "$RUNCVM_LOG_FILE" ] && [ "$RUNCVM_LOG_FILE" != "/dev/stderr" ]; then
       echo "$log_entry" >> "$RUNCVM_LOG_FILE" 2>/dev/null || true
    fi
    
    # Output to stderr if:
    # 1. It is an ERROR
    # 2. RUNCVM_LOG_FILE is NOT set
    # 3. RUNCVM_LOG_STDERR=1 is set
    if [ "$severity" = "ERROR" ] || [ -z "$RUNCVM_LOG_FILE" ] || [ "${RUNCVM_LOG_STDERR:-0}" = "1" ]; then
       echo "$log_entry" >&2
    fi
  fi
}

# Convenience functions for different severity levels
log_debug() {
  _log DEBUG "$@"
}

log_info() {
  _log INFO "$@"
}

log() {
  # Default log function - maps to INFO for backward compatibility
  _log INFO "$@"
}

log_error() {
  _log ERROR "$@"
}

error() {
  log_error "$@"
  exit 1
}


clean_env() {
  unset \
  RUNCVM_BREAK RUNCVM_INIT \
  RUNCVM_GUEST \
  RUNCVM_RUNTIME_DEBUG \
  RUNCVM_BIOS_DEBUG RUNCVM_BIOS \
  RUNCVM_DISPLAY_MODE \
  RUNCVM_KERNEL RUNCVM_KERNEL_ROOT RUNCVM_KERNEL_APPEND RUNCVM_KERNEL_INITRAMFS_PATH RUNCVM_KERNEL_DEBUG RUNCVM_KERNEL_PATH \
  RUNCVM_DISKS \
  RUNCVM_UIDGID RUNCVM_VM_MOUNTPOINT RUNCVM_TMPFS \
  RUNCVM_CPUS RUNCVM_MEM_SIZE RUNCVM_HUGETLB \
  RUNCVM_HAS_HOME \
  RUNCVM_VIRTIOFSD_CACHE \
  RUNCVM_CGROUPFS

  # May be set in VM by busybox init process
  unset USER
}

load_network() {
  local if="${1:-default}"
  [ -d /.runcvm/network/devices ] && [ -s /.runcvm/network/devices/$if ] || return 1
  read -r DOCKER_IF DOCKER_IF_MAC DOCKER_IF_MTU DOCKER_IF_IP DOCKER_IF_IP_NETPREFIX DOCKER_IF_IP_GW </.runcvm/network/devices/$if
  return 0
}

which() {
  local cmd="$1"
  local old_ifs="$IFS"
  IFS=':'
  set -- $RUNCVM_PATH
  IFS="$old_ifs"
  for p do
    if [ -x "$p/$cmd" ]; then
      echo "$p/$cmd"
      return 0
    fi
  done
  return 1
}

create_aliases() {
  for cmd in \
      bash \
      busybox awk cat chgrp chmod cut grep head hostname init ln ls mkdir mountpoint poweroff ps rm rmdir sh sysctl touch tr \
      jq \
      dnsmasq \
      blkid findmnt getent mke2fs resize2fs mount nc ping socat \
      dbclient dropbear dropbearkey \
      tput \
      debugfs
  do
    local cmd_path
    if cmd_path=$(which "$cmd"); then
      eval "$cmd() { $cmd_path \"\$@\"; }"
    fi
  done
}

create_aliases